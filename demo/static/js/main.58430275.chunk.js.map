{"version":3,"sources":["components/Game/TetrisConsts.tsx","components/Form/LoginForm.tsx","components/Prompt/GameControl.tsx","components/Game/TetrisUtils.tsx","components/Game/TetrisBoard.tsx","components/Game/Tetris.tsx","pages/Landing/Landing.tsx","pages/Home/Home.tsx","components/Form/ProfileCard.tsx","pages/Profile/Profile.tsx","App.tsx","index.tsx"],"names":["Command","Tile","Rotation","LoginFrom","className","htmlFor","type","id","href","GameControl","props","handleEscKey","bind","handleUnfocus","state","initialState","needRestart","promptVisible","this","document","addEventListener","removeEventListener","event","toggleGame","key","setState","preventDefault","visibilityState","toggleFirstGame","logInButton","renderLoginButton","onClick","isOver","restartGame","openForm","prompt","renderInitialPrompt","renderPrompt","React","Component","TILES_COORDS_ARR","RENDER_TILES_ARR","KEYBOARD_EVENT","DEFAULT_TIME_INTERVAL_MS","getNewTile","spawnedTiles","retTiles","retTile","shift","undefined","Error","length","push","Math","floor","random","newTile","newTiles","fieldToJsxElement","field","retField","forEach","col","rows","map","row","TetrisBoard","score","level","heldTile","firstGameStart","renderTiles","TetrisConsts","gameBoard","TetrisUtils","spawnedTilesFieldsRender","tile","spawnedTileFieldRender","Blank","tileRenderFields","heldTileFieldRender","Tetris","keyboardInputHandle","initStates","initNewGame","init","initGame","gameOver","initGameOver","newGameSwitch","gameRestart","onHold","initOnHold","activeTileX","initActiveTileX","activeTileY","initActiveTileY","activeGhostTileY","initActiveGhostTileY","initHeldTile","activeTile","initActiveTile","activeTileRotate","initActiveTileRotate","initScore","initLevel","progressSaved","initProgressSaved","tileCount","initTileCount","timerId","initField","initSpawnedTiles","setGameInterval","window","clearInterval","gameState","command","gamePaused","boardWidth","userAuth","handleNewGameClick","axios","put","JSON","stringify","newScore","timestamp","moment","format","headers","newInit","newOnHold","newX","newY","newGhostY","newHeldTile","newRotate","newField","xAdd","yAdd","rotateAdd","yAddValid","renderTile","Left","Right","Rotate","Down","HardDrop","HoldTile","isMoveValid","Up","prevTile","getTileRet","findGhostTileY","newStates","handleBlockedMovement","handleBoardUpdate","boardHeight","tiles","pixelIter","xToRender","yToRender","lowestY","isLineComplete","colArr","detectedRow","retX","retRotate","isGameOver","yToCheck","xToCheck","prev","newGameInterval","interval","newTimerId","setInterval","addX","addY","addRotate","xValid","spawnedTile","retRotation","retGhostTileY","prepareGhostTileY","x","y","initCol","tileX","tileY","tileRotate","yHigherThanCmp","yToCmpArr","yToCmp","includes","ret","iter","min","apply","upperBoundAttempts","renderValue","renderField","Landing","handleFormState","formOpened","isOpen","customBurgerIcon","onStateChange","outerContainerId","pageWrapId","width","Home","ProfileCard","emailAddress","displayName","profilePic","scores","get","userInfo","data","userScores","value","profilePicURL","backgroundImage","style","renderScores","Profile","App","exact","path","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.58430275.chunk.js","sourcesContent":["/* Misc consts */\nexport const MAX_PIXEL = 4;\nexport const MAX_ROTATE = 4;\nexport const Y_START = 0;\nexport const X_INDEX = 0;\nexport const Y_INDEX = 1;\nexport const UPPER_Y_INDEX = 2;\nexport const LOWER_Y_INDEX = 1;\nexport const UPPER_X_INDEX = 3;\nexport const LOWER_X_INDEX = 0;\nexport const MAX_SPAWNED_TILES = 4;\nexport const EARLY_LEVEL_MULTIPLIER = 60;\nexport const LATE_LEVEL_MULTIPLIER = 0.5;\nexport const INTERVAL_CAP = 900;\n\n/* Tiles coords consts */\nexport const MAX_TILE_INDEX = 7;\nexport const MIN_TILE_INDEX = 1;\nexport const GHOST_TILE_INDEX = 8;\nexport const TILES_COORDS_ARR = [\n  /**\n   * Each element in this array represents all 4 rotations of 1 tile\n   * Each rotation consists of 4 pixel coordinates [x, y] of the tile\n   *\n   * NOTE: there are places where the coordinate is -1, this is to specify\n   * which pixel is the center of rotation\n   */\n  [\n    /* Blank */\n    [[0, 0], [0, 0], [0, 0], [0, 0]],\n    [[0, 0], [0, 0], [0, 0], [0, 0]],\n    [[0, 0], [0, 0], [0, 0], [0, 0]],\n    [[0, 0], [0, 0], [0, 0], [0, 0]],\n  ],\n  [\n    /* 2x2 square tile */\n    [[-1, -1], [0, -1], [-1, 0], [0, 0]],\n    [[-1, -1], [0, -1], [-1, 0], [0, 0]],\n    [[-1, -1], [0, -1], [-1, 0], [0, 0]],\n    [[-1, -1], [0, -1], [-1, 0], [0, 0]],\n  ],\n  [\n    /* I tile */\n    [[-2, 0], [-1, 0], [0, 0], [1, 0]],\n    [[0, -1], [0, 0], [0, 1], [0, 2]],\n    [[-2, 0], [-1, 0], [0, 0], [1, 0]],\n    [[0, -1], [0, 0], [0, 1], [0, 2]],\n  ],\n  [\n    /* T tile */\n    [[-1, 0], [0, -1], [0, 0], [1, 0]],\n    [[0, 0], [0, -1], [0, 1], [1, 0]],\n    [[-1, 0], [0, 0], [0, 1], [1, 0]],\n    [[-1, 0], [0, -1], [0, 1], [0, 0]],\n  ],\n  [\n    /* J tile */\n    [[-1, 0], [-1, -1], [0, 0], [1, 0]],\n    [[0, 0], [0, -1], [0, 1], [1, -1]],\n    [[-1, 0], [0, 0], [1, 1], [1, 0]],\n    [[-1, 1], [0, -1], [0, 1], [0, 0]],\n  ],\n  [\n    /* L tile */\n    [[-1, 0], [1, -1], [0, 0], [1, 0]],\n    [[0, 0], [0, -1], [0, 1], [1, 1]],\n    [[-1, 0], [0, 0], [-1, 1], [1, 0]],\n    [[-1, -1], [0, -1], [0, 1], [0, 0]],\n  ],\n  [\n    /* Z tile */\n    [[-1, -1], [0, -1], [0, 0], [1, 0]],\n    [[0, 0], [1, -1], [0, 1], [1, 0]],\n    [[-1, -1], [0, -1], [0, 0], [1, 0]],\n    [[0, 0], [1, -1], [0, 1], [1, 0]],\n  ],\n  [\n    /* S tile */\n    [[-1, 0], [0, -1], [0, 0], [1, -1]],\n    [[0, 0], [0, -1], [1, 1], [1, 0]],\n    [[-1, 0], [0, -1], [0, 0], [1, -1]],\n    [[0, 0], [0, -1], [1, 1], [1, 0]],\n  ],\n];\nexport const RENDER_TILES_ARR = [\n  [\n    /* Blank */\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n  ],\n  [\n    /* 2x2 square tile */\n    [0, 0, 0, 0, 0],\n    [0, 1, 1, 0, 0],\n    [0, 1, 1, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n  ],\n  [\n    /* I tile */\n    [0, 0, 0, 0, 0],\n    [0, 0, 2, 0, 0],\n    [0, 0, 2, 0, 0],\n    [0, 0, 2, 0, 0],\n    [0, 0, 2, 0, 0],\n  ],\n  [\n    /* T tile */\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 3, 0, 0],\n    [0, 3, 3, 3, 0],\n    [0, 0, 0, 0, 0],\n  ],\n  [\n    /* J tile */\n    [0, 0, 0, 0, 0],\n    [0, 0, 4, 0, 0],\n    [0, 0, 4, 0, 0],\n    [0, 4, 4, 0, 0],\n    [0, 0, 0, 0, 0],\n  ],\n  [\n    /* L tile */\n    [0, 0, 0, 0, 0],\n    [0, 0, 5, 0, 0],\n    [0, 0, 5, 0, 0],\n    [0, 0, 5, 5, 0],\n    [0, 0, 0, 0, 0],\n  ],\n  [\n    /* Z tile */\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 6, 6, 0, 0],\n    [0, 0, 6, 6, 0],\n    [0, 0, 0, 0, 0],\n  ],\n  [\n    /* S tile */\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 7, 7, 0],\n    [0, 7, 7, 0, 0],\n    [0, 0, 0, 0, 0],\n  ],\n];\n\n/* Keyboard event consts */\nexport const ARROW_DOWN = 'ArrowDown';\nexport const ARROW_LEFT = 'ArrowLeft';\nexport const ARROW_UP = 'ArrowUp';\nexport const ARROW_RIGHT = 'ArrowRight';\nexport const SPACE = ' ';\nexport const C_KEY = 'c';\nexport const KEYBOARD_EVENT = 'keydown';\n\n/* Timer consts */\nexport const DEFAULT_TIME_INTERVAL_MS = 1000;\n\n/* Enum 'types' */\nexport enum Command {\n  Down,\n  Left,\n  Right,\n  Rotate,\n  HardDrop,\n  HoldTile,\n}\n\nexport enum Tile {\n  Blank,\n  Square,\n  I,\n  T,\n  J,\n  L,\n  Z,\n  S,\n}\n\nexport enum Rotation {\n  Up,\n  Right,\n  Down,\n  Left,\n}\n","import React from 'react';\n\nimport './LoginForm.css';\n\nconst LoginFrom: React.FC<Record<string, unknown>> = () => (\n  <div className=\"form\">\n    <h1>TetriBASS</h1>\n    <form>\n      <div className=\"mb-2\">\n        <label className=\"form-label\" htmlFor=\"username-input\">\n          Email address\n          <input type=\"email\" className=\"form-control-custom\" id=\"username-input\" />\n        </label>\n      </div>\n      <div className=\"mb-2\">\n        <label className=\"form-label\" htmlFor=\"password-input\">\n          Password\n          <input type=\"password\" className=\"form-control-custom\" id=\"password-input\" />\n        </label>\n      </div>\n      <div className=\"mb-3 form-buttons\">\n        <button type=\"submit\" className=\"btn-custom btn-custom-light btn-block\">Register Now</button>\n        <div />\n        <button type=\"submit\" className=\"btn-custom btn-custom-dark btn-block\">Log In</button>\n      </div>\n      <div className=\"mb-3 form-separator\">\n        Or\n      </div>\n      <div>\n        <a className=\"btn-custom btn-custom-dark btn-block google-log-in\" href=\"/auth/google\">Log In with Google</a>\n      </div>\n    </form>\n  </div>\n);\n\nexport default LoginFrom;\n","import React from 'react';\n\nimport './GameControl.css';\n\ntype GameControlProps = {\n  isOver: boolean;\n  toggleGame: () => void;\n  restartGame: () => void;\n  openForm?: () => void;\n  toggleFirstGame: () => void;\n};\n\ntype GameControlState = {\n  initialState: boolean;\n  needRestart: boolean;\n  promptVisible: boolean;\n};\n\nclass GameControl extends React.Component<GameControlProps, GameControlState> {\n  constructor(props: GameControlProps) {\n    super(props);\n\n    this.handleEscKey = this.handleEscKey.bind(this);\n    this.handleUnfocus = this.handleUnfocus.bind(this);\n\n    this.state = {\n      initialState: true,\n      needRestart: false,\n      promptVisible: true,\n    };\n  }\n\n  static getDerivedStateFromProps(\n    props: GameControlProps,\n    state: GameControlState,\n  ): Record<string, unknown> | null {\n    if (props.isOver && !state.promptVisible) {\n      return {\n        promptVisible: true,\n      };\n    }\n\n    if (!props.isOver && state.needRestart) {\n      return {\n        promptVisible: false,\n        needRestart: false,\n      };\n    }\n\n    return null;\n  }\n\n  componentDidMount(): void {\n    const { handleEscKey, handleUnfocus } = this;\n\n    document.addEventListener('keydown', handleEscKey);\n    document.addEventListener('visibilitychange', handleUnfocus);\n  }\n\n  componentWillUnmount(): void {\n    const { handleEscKey, handleUnfocus } = this;\n\n    document.removeEventListener('keydown', handleEscKey);\n    document.removeEventListener('visibilitychange', handleUnfocus);\n  }\n\n  /**\n   * @brief: handleEscKey: Callback for the event of the Escape key being received; pause the game\n   * and pull up the game control prompt\n   * @param[in]: event - The keyboard event received\n   */\n  handleEscKey(event: KeyboardEvent): void {\n    const { toggleGame } = this.props;\n    const { promptVisible } = this.state;\n\n    if (event.key !== 'Escape') {\n      event.preventDefault();\n      return;\n    }\n\n    toggleGame();\n    this.setState({ promptVisible: !promptVisible });\n  }\n\n  /**\n   * @brief: handleUnfocus: Callback for the event of visibility status of the document being\n   * changed; key being received; pause the game and pull up the game control prompt\n   */\n  handleUnfocus(): void {\n    const { toggleGame } = this.props;\n    const { promptVisible } = this.state;\n\n    if (!promptVisible && document.visibilityState !== 'visible') {\n      toggleGame();\n      this.setState({ promptVisible: true });\n    }\n  }\n\n  renderInitialPrompt(): JSX.Element {\n    const { toggleFirstGame } = this.props;\n\n    const logInButton = this.renderLoginButton();\n\n    return (\n      <div>\n        <button\n          type=\"submit\"\n          className=\"mb-2 btn-custom btn-custom-light btn-block\"\n          onClick={(): void => {\n            toggleFirstGame();\n            this.setState({\n              initialState: false,\n              promptVisible: false,\n            });\n          }}\n        >\n          Play\n        </button>\n        { logInButton }\n      </div>\n    );\n  }\n\n  renderPrompt(): JSX.Element {\n    const { isOver, toggleGame, restartGame } = this.props;\n\n    const logInButton = this.renderLoginButton();\n\n    return (\n      <div>\n        { isOver ? (\n          <h2>Game Over</h2>\n        ) : (\n          <button\n            type=\"submit\"\n            className=\"mb-2 btn-custom btn-custom-light btn-block\"\n            onClick={(): void => {\n              toggleGame();\n              this.setState({ promptVisible: false });\n            }}\n          >\n            Resume\n          </button>\n        )}\n        <button\n          type=\"submit\"\n          className=\"mb-2 btn-custom btn-custom-dark btn-block\"\n          onClick={(): void => {\n            restartGame();\n            this.setState({\n              promptVisible: false,\n              needRestart: true,\n            });\n          }}\n        >\n          Restart\n        </button>\n        { logInButton }\n      </div>\n    );\n  }\n\n  renderLoginButton(): JSX.Element {\n    const { openForm } = this.props;\n\n    return openForm ? (\n      <button\n        type=\"submit\"\n        className=\"btn-custom btn-custom-dark btn-block\"\n        onClick={(): void => openForm()}\n      >\n        Log In\n      </button>\n    ) : (\n      <a\n        className=\"btn-custom btn-custom-dark btn-block\"\n        href=\"/logout\"\n      >\n        Log Out\n      </a>\n    );\n  }\n\n  render(): JSX.Element {\n    const { initialState, promptVisible } = this.state;\n\n    const prompt = initialState ? this.renderInitialPrompt() : this.renderPrompt();\n\n    return (\n      <div className=\"game-control-wrap\">\n        <div className={`game-control game-control-${promptVisible ? 'visible' : 'hidden'}`}>\n          { prompt }\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default GameControl;\n","import * as TetrisConsts from './TetrisConsts';\n\n/**\n * @brief: getNewTile: Get a tile from the spawned tiles queue.\n * If the queue's size is less than the maximum size, we add to it\n * a new tile.\n * @param[in]: tiles - Spawned tiles queue\n * @return: newTile - Tile pop from the queue\n *          newTiles - Updated queue\n */\nexport function getNewTile(spawnedTiles: TetrisConsts.Tile[]): {\n  newTile: TetrisConsts.Tile;\n  newTiles: TetrisConsts.Tile[];\n} {\n  const retTiles = spawnedTiles;\n  const retTile = retTiles.shift();\n  /* Shift method might return undefined */\n  if (retTile === undefined) {\n    throw new Error('Cannot fetch a new tile from tile array');\n  }\n\n  /* Add a new tile to spawned tiles queue if size is less than max size */\n  if (retTiles.length < TetrisConsts.MAX_SPAWNED_TILES) {\n    retTiles.push(Math.floor(Math.random()\n    * (TetrisConsts.MAX_TILE_INDEX - TetrisConsts.MIN_TILE_INDEX + 1)) + 1);\n  }\n\n  return {\n    newTile: retTile,\n    newTiles: retTiles,\n  };\n}\n\n/**\n * @brief: fieldToJsxElement: Convert a field of coords to a JSX element for render\n * @param[in]: field - Field to render\n * @return: JSX element of field\n */\nexport function fieldToJsxElement(field: number[][]): JSX.Element[] {\n  const retField: JSX.Element[] = [];\n\n  field.forEach((col) => {\n    // eslint-disable-next-line react/react-in-jsx-scope\n    const rows = col.map((row: number) => <div className={`row-${row}`} />);\n    // eslint-disable-next-line react/react-in-jsx-scope\n    retField.push(<div className=\"tetris-col\">{rows}</div>);\n  });\n\n  return retField;\n}\n\nexport default {\n  getNewTile,\n  fieldToJsxElement,\n};\n","import React from 'react';\n\nimport * as TetrisConsts from './TetrisConsts';\nimport * as TetrisUtils from './TetrisUtils';\n\ntype TetrisBoardProps =\n{\n  field: number[][];\n  score: number;\n  level: number;\n  spawnedTiles: TetrisConsts.Tile[];\n  heldTile: TetrisConsts.Tile;\n  firstGameStart: boolean;\n};\n\nconst TetrisBoard: React.FC<TetrisBoardProps> = (props: TetrisBoardProps) => {\n  const {\n    field, score, level, spawnedTiles, heldTile, firstGameStart,\n  } = props;\n  const renderTiles = TetrisConsts.RENDER_TILES_ARR;\n\n  /* Prepare an HTML element for the main game board */\n  const gameBoard = TetrisUtils.fieldToJsxElement(field);\n\n  /* Prepare HTML elements for the tile queue */\n  const spawnedTilesFieldsRender: JSX.Element[][] = [];\n  spawnedTiles.forEach((tile) => {\n    const spawnedTileField = firstGameStart ? renderTiles[tile]\n      : renderTiles[TetrisConsts.Tile.Blank];\n    const spawnedTileFieldRender = TetrisUtils.fieldToJsxElement(spawnedTileField);\n    spawnedTilesFieldsRender.push(spawnedTileFieldRender);\n  });\n  const tileRenderFields = spawnedTilesFieldsRender.map((tile) => <div className=\"tetris-next\">{tile}</div>);\n\n  /* Prepare an HTML element for the currently held tile */\n  const heldTileField = renderTiles[heldTile];\n  const heldTileFieldRender = TetrisUtils.fieldToJsxElement(heldTileField);\n\n  return (\n    <div>\n      <div className=\"tetris-info\">\n        <div className=\"row\">\n          <div className=\"col\">\n            <p>\n              LEVEL\n            </p>\n            <p>\n              {level}\n            </p>\n          </div>\n          <div className=\"col\">\n            <p>\n              SCORE\n            </p>\n            <p>\n              {score}\n            </p>\n          </div>\n        </div>\n      </div>\n      <div className=\"tetris-gamespace\">\n        <div className=\"row\">\n          <div className=\"col\">\n            <div className=\"tetris-held\">{heldTileFieldRender}</div>\n          </div>\n          <div className=\"col\">\n            <div className=\"tetris-board\">{gameBoard}</div>\n          </div>\n          <div className=\"col\">\n            <div>{tileRenderFields}</div>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default TetrisBoard;\n","import React from 'react';\nimport axios from 'axios';\nimport moment from 'moment';\n\nimport TetrisBoard from './TetrisBoard';\nimport './Tetris.css';\nimport * as TetrisConsts from './TetrisConsts';\nimport * as TetrisUtils from './TetrisUtils';\n\ntype TetrisProps = {\n  boardWidth: number;\n  boardHeight: number;\n  gamePaused: boolean;\n  gameRestart: boolean; /* We now use the newGame prop as a 'switch' to toggle a new game\n  instead of polling its' value to determine whether or not a new game should start */\n  gameState: (arg0: boolean) => void; /* We use a callback as another switch to let the\n  parent component know whether the game is over */\n  firstGameStart: boolean;\n  userAuth: boolean;\n};\n\ntype TetrisCol = {\n  colArr: number[];\n  lowestY: number;\n};\n\ntype TetrisState = {\n  init: boolean;\n  gameOver: boolean;\n  newGameSwitch: boolean;\n  onHold: boolean;\n  activeTileX: number;\n  activeTileY: number;\n  activeGhostTileY: number;\n  heldTile: TetrisConsts.Tile;\n  activeTile: TetrisConsts.Tile;\n  activeTileRotate: TetrisConsts.Rotation;\n  score: number;\n  level: number;\n  progressSaved: boolean;\n  tileCount: number;\n  timerId: number;\n  field: TetrisCol[];\n  spawnedTiles: TetrisConsts.Tile[];\n};\n\nclass Tetris extends React.Component<TetrisProps, TetrisState> {\n  constructor(props: TetrisProps) {\n    super(props);\n\n    /* Binding handles */\n    this.keyboardInputHandle = this.keyboardInputHandle.bind(this);\n\n    const initStates = this.initNewGame();\n\n    this.state = {\n      init: initStates.initGame,\n      gameOver: initStates.initGameOver,\n      newGameSwitch: props.gameRestart,\n      onHold: initStates.initOnHold,\n      activeTileX: initStates.initActiveTileX,\n      activeTileY: initStates.initActiveTileY,\n      activeGhostTileY: initStates.initActiveGhostTileY,\n      heldTile: initStates.initHeldTile,\n      activeTile: initStates.initActiveTile,\n      activeTileRotate: initStates.initActiveTileRotate,\n      score: initStates.initScore,\n      level: initStates.initLevel,\n      progressSaved: initStates.initProgressSaved,\n      tileCount: initStates.initTileCount,\n      timerId: 0,\n      field: initStates.initField,\n      spawnedTiles: initStates.initSpawnedTiles,\n    };\n  }\n\n  componentDidMount(): void {\n    const { keyboardInputHandle } = this;\n\n    document.addEventListener(TetrisConsts.KEYBOARD_EVENT, keyboardInputHandle);\n\n    this.setGameInterval(TetrisConsts.DEFAULT_TIME_INTERVAL_MS);\n  }\n\n  componentWillUnmount(): void {\n    const { keyboardInputHandle } = this;\n    const {\n      timerId,\n    } = this.state;\n\n    document.removeEventListener(TetrisConsts.KEYBOARD_EVENT, keyboardInputHandle);\n\n    window.clearInterval(timerId);\n  }\n\n  /**\n   * @brief: handleNewGameClick: Callback for the event of the new game\n   * button being clicked on\n   */\n  handleNewGameClick(): void {\n    const {\n      gameRestart, gameState,\n    } = this.props;\n\n    /* Call gameState callback to reset parent's gameOver prop */\n    gameState(false);\n\n    const initStates = this.initNewGame();\n\n    this.setState(() => ({\n      init: initStates.initGame,\n      gameOver: initStates.initGameOver,\n      newGameSwitch: gameRestart,\n      onHold: initStates.initOnHold,\n      activeTileX: initStates.initActiveTileX,\n      activeTileY: initStates.initActiveTileY,\n      activeGhostTileY: initStates.initActiveGhostTileY,\n      activeTile: initStates.initActiveTile,\n      heldTile: initStates.initHeldTile,\n      activeTileRotate: initStates.initActiveTileRotate,\n      score: initStates.initScore,\n      level: initStates.initLevel,\n      progressSaved: initStates.initProgressSaved,\n      tileCount: initStates.initTileCount,\n      field: initStates.initField,\n      spawnedTiles: initStates.initSpawnedTiles,\n    }));\n\n    /* Reset timer */\n    this.setGameInterval(TetrisConsts.DEFAULT_TIME_INTERVAL_MS);\n  }\n\n  /**\n   * @brief: handleBoardUpdate: Handler for each 'tick' of the game\n   * or when a command is issued\n   * @param[in]: command - The command to be executed. The command is\n   * always 'Down' for each tick of the game\n   */\n  async handleBoardUpdate(command: TetrisConsts.Command): Promise<void> {\n    const {\n      gamePaused, gameRestart, gameState, boardWidth, userAuth,\n    } = this.props;\n\n    const {\n      init, gameOver, newGameSwitch, onHold, activeTileX, activeTileY, activeGhostTileY,\n      heldTile, activeTile, activeTileRotate, score, field, progressSaved, spawnedTiles,\n    } = this.state;\n\n    /* Call new game handler and return if the new game/restart button was clicked */\n    if (newGameSwitch !== gameRestart) {\n      this.handleNewGameClick();\n\n      return;\n    }\n\n    /* Call gameState callback, save user's score and return if game is over */\n    if (gameOver) {\n      gameState(true);\n\n      if (userAuth && !progressSaved) {\n        await axios.put('/api/user/update/scores', JSON.stringify({\n          newScore: {\n            score,\n            timestamp: moment().format('MMMM Do, YYYY'),\n          },\n        }), {\n          headers: {\n            'Content-Type': 'application/json',\n          },\n        });\n\n        this.setState({\n          progressSaved: true,\n        });\n      }\n\n      return;\n    }\n\n    /* Return if game is paused */\n    if (gamePaused) {\n      return;\n    }\n\n    let newInit = init;\n    let newOnHold = onHold;\n    let newX = activeTileX;\n    let newY = activeTileY;\n    let newGhostY = activeGhostTileY;\n    let newHeldTile = heldTile;\n    let newTile = activeTile;\n    let newRotate = activeTileRotate;\n    let newField = field;\n    let newTiles = spawnedTiles;\n\n    let xAdd = 0;\n    let yAdd = 0;\n    let rotateAdd = 0;\n    let yAddValid = true;\n\n    /* Handling init - We only render the newly spawned tile */\n    if (init) {\n      this.renderTile(newX, newGhostY, newTile, newRotate, TetrisConsts.GHOST_TILE_INDEX);\n      this.renderTile(newX, newY, newTile, newRotate, newTile);\n      this.setState(() => ({\n        init: false,\n      }));\n\n      return;\n    }\n\n    /* Remove current tile from field for next logic */\n    this.renderTile(newX, newGhostY, newTile, newRotate, 0);\n    this.renderTile(newX, newY, newTile, newRotate, 0);\n\n    /* Determine which value to be modified (x - y - rotate ?) */\n    switch (command) {\n      case TetrisConsts.Command.Left: {\n        xAdd = -1;\n        if (this.isMoveValid(newX, xAdd, newY, 0, newTile, newRotate, 0)) {\n          newX += xAdd;\n        }\n        break;\n      }\n      case TetrisConsts.Command.Right: {\n        xAdd = 1;\n        if (this.isMoveValid(newX, xAdd, newY, 0, newTile, newRotate, 0)) {\n          newX += xAdd;\n        }\n        break;\n      }\n      case TetrisConsts.Command.Rotate: {\n        rotateAdd = 1;\n        if (this.isMoveValid(newX, 0, newY, 0, newTile, newRotate, rotateAdd)) {\n          newRotate = newRotate + rotateAdd === TetrisConsts.MAX_ROTATE\n            ? TetrisConsts.Rotation.Up : (newRotate + rotateAdd);\n        }\n        break;\n      }\n      case TetrisConsts.Command.Down: {\n        yAdd = 1;\n        yAddValid = this.isMoveValid(newX, 0, newY, yAdd, newTile, newRotate, 0);\n        if (yAddValid) {\n          newY += yAdd;\n        }\n        break;\n      }\n      case TetrisConsts.Command.HardDrop: {\n        newY = newGhostY;\n        yAddValid = false;\n        break;\n      }\n      case TetrisConsts.Command.HoldTile: {\n        if (!newOnHold) {\n          if (newHeldTile !== TetrisConsts.Tile.Blank) {\n            const prevTile = newTile;\n            newTile = newHeldTile;\n            newHeldTile = prevTile;\n          } else {\n            const getTileRet = TetrisUtils.getNewTile(newTiles);\n            newHeldTile = newTile;\n            newTile = getTileRet.newTile;\n            newTiles = getTileRet.newTiles;\n          }\n          newX = Math.floor(boardWidth / 2);\n          newY = TetrisConsts.Y_START;\n          newRotate = TetrisConsts.Rotation.Up;\n          newOnHold = true;\n        }\n        break;\n      }\n      default: {\n        return;\n      }\n    }\n\n    /* Render new tile after the new coords are updated */\n    newGhostY = this.findGhostTileY(newX, newY, newTile, newRotate);\n    this.renderTile(newX, newGhostY, newTile, newRotate, TetrisConsts.GHOST_TILE_INDEX);\n    this.renderTile(newX, newY, newTile, newRotate, newTile);\n\n    /* Handling blocked movement */\n    if (!yAddValid) {\n      const newStates = this.handleBlockedMovement(newX, newY, newTile, newRotate);\n      /* Game over */\n      if (newStates === undefined) {\n        return;\n      }\n\n      newInit = newStates.newInit;\n      newX = newStates.newX;\n      newY = newStates.newY;\n      newTile = newStates.newTile;\n      newRotate = newStates.newRotate;\n      newGhostY = this.findGhostTileY(newX, newY, newTile, newRotate);\n      newField = newStates.newField;\n      newTiles = newStates.newTiles;\n      newOnHold = (newOnHold === true) ? false : newOnHold;\n    }\n\n    /* Update new states */\n    this.setState(() => ({\n      init: newInit,\n      onHold: newOnHold,\n      activeTileX: newX,\n      activeTileY: newY,\n      activeGhostTileY: newGhostY,\n      heldTile: newHeldTile,\n      activeTile: newTile,\n      activeTileRotate: newRotate,\n      field: newField,\n      spawnedTiles: newTiles,\n    }));\n\n    /* TBS-36: Getting new tile to spawn immediately\n\n    This recursive call should not affect performance as we'd fall in the init\n    handling section of this function - which should return anyway. Unless I'm wrong..? */\n    if (!yAddValid) {\n      await this.handleBoardUpdate(TetrisConsts.Command.Down);\n    }\n  }\n\n  /**\n   * @brief: handleBlockedMovement: Handle for blocked movements\n   * @param[in]: activeTileX: Rendered X coord\n   * @param[in]: activeTileY: Rendered Y coord\n   * @return: Object containing the updated value for states; returning\n   * undefined if game is over\n   */\n  handleBlockedMovement(activeTileX: number,\n    activeTileY: number,\n    activeTile: TetrisConsts.Tile,\n    activeTileRotate: TetrisConsts.Rotation): {\n      newInit: boolean;\n      newX: number;\n      newY: number;\n      newTile: TetrisConsts.Tile;\n      newRotate: TetrisConsts.Rotation;\n      newField: TetrisCol[];\n      newTiles: TetrisConsts.Tile[];\n    } | undefined {\n    const { field, spawnedTiles, level } = this.state;\n    const { boardWidth, boardHeight } = this.props;\n\n    const tiles = TetrisConsts.TILES_COORDS_ARR;\n\n    const retField = field;\n\n    /* Update the lowest pixel for each column */\n    for (let pixelIter = 0; pixelIter < TetrisConsts.MAX_PIXEL; pixelIter += 1) {\n      const xToRender = activeTileX + tiles[activeTile][activeTileRotate][\n        pixelIter][TetrisConsts.X_INDEX];\n      const yToRender = activeTileY + tiles[activeTile][activeTileRotate][\n        pixelIter][TetrisConsts.Y_INDEX];\n      if (yToRender >= 0) {\n        const { lowestY } = retField[xToRender];\n        if (lowestY > yToRender) {\n          retField[xToRender].lowestY = yToRender;\n        }\n      }\n    }\n\n    /* Check for complete lines and clear if there are any */\n    for (let row = boardHeight - 1; row >= 0; row -= 1) {\n      let isLineComplete = true;\n\n      for (let col = 0; col < boardWidth; col += 1) {\n        if (retField[col].colArr[row] === 0) {\n          isLineComplete = false;\n          break;\n        }\n      }\n\n      if (isLineComplete) {\n        for (let detectedRow = row; detectedRow > 0; detectedRow -= 1) {\n          for (let col = 0; col < boardWidth; col += 1) {\n            retField[col].colArr[detectedRow] = retField[col].colArr[detectedRow - 1];\n          }\n        }\n        row += 1;\n\n        /* Update the lowest row value for each col */\n        for (let col = 0; col < boardWidth; col += 1) {\n          if (retField[col].lowestY !== boardHeight - 1) {\n            retField[col].lowestY += 1;\n          }\n        }\n      }\n    }\n\n    /* Prepare new tile for the next board update */\n    const getTileRet = TetrisUtils.getNewTile(spawnedTiles);\n    const retTile = getTileRet.newTile;\n    const retTiles = getTileRet.newTiles;\n\n    const retX = Math.floor(boardWidth / 2);\n    const retY = TetrisConsts.Y_START;\n    const retRotate = TetrisConsts.Rotation.Up;\n\n    /* Check if game is over. If not, update score + spawn a new tile\n    + set new time interval and continue */\n    let isGameOver = false;\n    for (let pixelIter = 0; pixelIter < TetrisConsts.MAX_PIXEL; pixelIter += 1) {\n      const yToCheck = retY + tiles[retTile][retRotate][pixelIter][TetrisConsts.Y_INDEX];\n      const xToCheck = retX + tiles[retTile][retRotate][pixelIter][TetrisConsts.X_INDEX];\n      if (yToCheck >= 0) {\n        if (retField[xToCheck].colArr[yToCheck] !== 0) {\n          isGameOver = true;\n          break;\n        }\n      }\n    }\n\n    if (isGameOver) {\n      this.setState(() => ({\n        gameOver: true,\n      }));\n      return undefined;\n    }\n\n    this.setState((prev) => ({\n      score: prev.score + 1 * prev.level,\n      tileCount: prev.tileCount + 1,\n      level: 1 + Math.floor(prev.tileCount / 10),\n    }));\n\n    const newGameInterval = level * TetrisConsts.EARLY_LEVEL_MULTIPLIER > TetrisConsts.INTERVAL_CAP\n      ? (TetrisConsts.INTERVAL_CAP + level * TetrisConsts.LATE_LEVEL_MULTIPLIER)\n      : (level * TetrisConsts.EARLY_LEVEL_MULTIPLIER);\n    this.setGameInterval(TetrisConsts.DEFAULT_TIME_INTERVAL_MS - newGameInterval);\n\n    return {\n      newInit: true,\n      newX: retX,\n      newY: retY,\n      newTile: retTile,\n      newRotate: retRotate,\n      newField: retField,\n      newTiles: retTiles,\n    };\n  }\n\n  /**\n   * @brief: setGameInterval: Set the pace/speed of the game\n   * @param[in]: interval(ms) - The 'pace' of the game to be set;\n   * the lower the value is, the faster the game becomes\n   */\n  setGameInterval(interval: number): void {\n    const {\n      timerId,\n    } = this.state;\n\n    window.clearInterval(timerId);\n\n    const newTimerId = window.setInterval(\n      () => this.handleBoardUpdate(TetrisConsts.Command.Down),\n      interval,\n    );\n\n    this.setState(() => ({\n      timerId: newTimerId,\n    }));\n  }\n\n  /**\n   * @brief: keyboardInputHandle: Callback for the event of keyboard\n   * input being received; translate the event keycode to the corresponding\n   * command\n   * @param[in]: event - The keyboard event received\n   */\n  async keyboardInputHandle(event: KeyboardEvent): Promise<void> {\n    switch (event.key) {\n      case TetrisConsts.ARROW_DOWN:\n        await this.handleBoardUpdate(TetrisConsts.Command.Down);\n        break;\n      case TetrisConsts.ARROW_LEFT:\n        await this.handleBoardUpdate(TetrisConsts.Command.Left);\n        break;\n      case TetrisConsts.ARROW_UP:\n        await this.handleBoardUpdate(TetrisConsts.Command.Rotate);\n        break;\n      case TetrisConsts.ARROW_RIGHT:\n        await this.handleBoardUpdate(TetrisConsts.Command.Right);\n        break;\n      case TetrisConsts.SPACE:\n        await this.handleBoardUpdate(TetrisConsts.Command.HardDrop);\n        break;\n      case TetrisConsts.C_KEY:\n        await this.handleBoardUpdate(TetrisConsts.Command.HoldTile);\n        break;\n      default:\n    }\n  }\n\n  /**\n   * @brief: isMoveValid: Check if this next move is being valid\n   * or not:\n   *  Does it go out of the board?\n   *  Is is blocked by other tiles?\n   * @param[in]: activeTileX - Current x value\n   * @param[in]: addX - Amount of x to be added\n   * @param[in]: activeTileY - Current y value\n   * @param[in]: addY - Amount of y to be added\n   * @param[in]: activeTile - Current tile type\n   * @param[in]: activeTileRotate - Current rotation\n   * @param[in]: addRotate - Amount of rotation to be added\n   * @return: True if the move is valid, false otw\n   */\n  isMoveValid(activeTileX: number,\n    addX: number,\n    activeTileY: number,\n    addY: number,\n    activeTile: TetrisConsts.Tile,\n    activeTileRotate: TetrisConsts.Rotation,\n    addRotate: number): boolean {\n    const { field } = this.state;\n    const { boardWidth, boardHeight } = this.props;\n\n    const tiles = TetrisConsts.TILES_COORDS_ARR;\n\n    const newX = addX ? (activeTileX + addX) : activeTileX;\n    const newY = addY ? (activeTileY + addY) : activeTileY;\n    const newRotate = activeTileRotate + addRotate === TetrisConsts.MAX_ROTATE\n      ? TetrisConsts.Rotation.Up : (activeTileRotate + addRotate);\n\n    /* We scan through each pixel of the tile to determine if the move is valid */\n    for (let pixelIter = 0; pixelIter < TetrisConsts.MAX_PIXEL; pixelIter += 1) {\n      /* Check to see if any pixel goes out of the board */\n      /* HACK - We check pixels' y coords first to safely render tiles\n      pixel by pixel initially */\n      const yToCheck = newY + tiles[activeTile][newRotate][pixelIter][TetrisConsts.Y_INDEX];\n      const xToCheck = newX + tiles[activeTile][newRotate][pixelIter][TetrisConsts.X_INDEX];\n      const xValid = xToCheck >= 0 && xToCheck < boardWidth;\n      if (yToCheck >= 0) {\n        const yValid = yToCheck < boardHeight;\n        if (xValid && yValid) {\n          /* Check for any overlap */\n          const pixelOverlapped = field[xToCheck].colArr[yToCheck] !== 0;\n          if (pixelOverlapped) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      } else if (!xValid) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @brief: initNewGame: Init a new game by calculating new x value\n   * and randomizing the new tile\n   * @return: Object containing the init value for states\n   */\n  initNewGame(): { initGame: boolean;\n    initGameOver: boolean;\n    initOnHold: boolean;\n    initActiveTileX: number;\n    initActiveTileY: number;\n    initActiveGhostTileY: number;\n    initHeldTile: TetrisConsts.Tile;\n    initActiveTile: TetrisConsts.Tile;\n    initActiveTileRotate: TetrisConsts.Rotation;\n    initScore: number;\n    initLevel: number;\n    initProgressSaved: boolean;\n    initTileCount: number;\n    initField: TetrisCol[];\n    initSpawnedTiles: TetrisConsts.Tile[];\n  } {\n    const { boardWidth, boardHeight } = this.props;\n\n    const retTiles = [];\n    /* Add an additional tile to pop in init */\n    for (let pixelIter = 0; pixelIter < TetrisConsts.MAX_SPAWNED_TILES + 1; pixelIter += 1) {\n      const spawnedTile = Math.floor(Math.random()\n        * (TetrisConsts.MAX_TILE_INDEX - TetrisConsts.MIN_TILE_INDEX + 1)) + 1;\n      retTiles.push(spawnedTile);\n    }\n    const getTileRet = TetrisUtils.getNewTile(retTiles);\n    const retTile = getTileRet.newTile;\n    const retRotation = TetrisConsts.Rotation.Up;\n    const retGhostTileY = this.prepareGhostTileY(retTile, retRotation);\n\n    const retField: TetrisCol[] = [];\n    for (let x = 0; x < boardWidth; x += 1) {\n      const col: number[] = [];\n      for (let y = 0; y < boardHeight; y += 1) {\n        col.push(0);\n      }\n      const initCol: TetrisCol = {\n        colArr: col,\n        lowestY: boardHeight - 1,\n      };\n      retField.push(initCol);\n    }\n\n    return {\n      initGame: true,\n      initGameOver: false,\n      initOnHold: false,\n      initActiveTileX: Math.floor(boardWidth / 2),\n      initActiveTileY: TetrisConsts.Y_START,\n      initActiveGhostTileY: retGhostTileY,\n      initHeldTile: TetrisConsts.Tile.Blank,\n      initActiveTile: retTile,\n      initActiveTileRotate: retRotation,\n      initScore: 0,\n      initLevel: 1,\n      initProgressSaved: false,\n      initTileCount: 0,\n      initField: retField,\n      initSpawnedTiles: retTiles,\n    };\n  }\n\n  /**\n   * @brief: findGhostTileY: Find the optimal Y for the ghost tile\n   * @param[in]: tileX - Actual tile's x\n   * @param[in]: tileY - Actual tile's y\n   * @param[in]: tile - Actual tile type\n   * @param[in]: tileRotate - Actual tile's rotation\n   */\n  findGhostTileY(tileX: number,\n    tileY: number,\n    tile: TetrisConsts.Tile,\n    tileRotate: TetrisConsts.Rotation): number {\n    const { boardWidth, boardHeight } = this.props;\n    const { field } = this.state;\n\n    const tiles = TetrisConsts.TILES_COORDS_ARR;\n\n    /* First we find the lowest Y among the number of cols this\n    tile spans */\n    let yHigherThanCmp = false;\n    const yToCmpArr: number[] = [];\n    for (let pixelIter = 0; pixelIter < TetrisConsts.MAX_PIXEL; pixelIter += 1) {\n      const xToCheck = tileX + tiles[tile][tileRotate][pixelIter][TetrisConsts.X_INDEX];\n      const yToCheck = tileY + tiles[tile][tileRotate][pixelIter][TetrisConsts.Y_INDEX];\n      if (yToCheck >= 0) {\n        const xValid = xToCheck >= 0 && xToCheck < boardWidth;\n        const yValid = yToCheck < boardHeight;\n        if (xValid && yValid) {\n          const yToCmp = field[xToCheck].lowestY;\n          /* If the current tile is already higher than the\n          lowest Y among the X range, we have to handle it differently */\n          if (yToCheck > yToCmp) {\n            yHigherThanCmp = true;\n            break;\n          }\n          if (!yToCmpArr.includes(yToCmp)) {\n            yToCmpArr.push(yToCmp);\n          }\n        }\n      }\n    }\n\n    let ret = 0;\n    /* We have to manually look for the best fit of the\n    tile since the lowest Y doesn't help here */\n    if (yHigherThanCmp) {\n      let iter = 0;\n      while (this.isMoveValid(tileX, 0, tileY, iter, tile, tileRotate, 0)) {\n        iter += 1;\n      }\n      ret = tileY + iter - 1;\n      return ret;\n    }\n\n    const lowestY = Math.min.apply(null, yToCmpArr);\n    /* We find the correct starting point for the pivot */\n    const pixelsToPivot = tiles[tile][tileRotate][\n      TetrisConsts.UPPER_Y_INDEX][TetrisConsts.Y_INDEX];\n    ret = lowestY - 1 - pixelsToPivot;\n\n    /* Since we might change the pivot for the tiles in the future,\n      it is best to try to find the best fit for the tile starting from\n      the lowest Y we just found. We first try to go upwards (Y increases) */\n    let upperBoundAttempts = 0;\n    while (this.isMoveValid(tileX, 0, ret, 1, tile, tileRotate, 0)) {\n      ret += 1;\n      upperBoundAttempts += 1;\n    }\n    /* If the number of attempts to move Y upwards is not 0, it means that the\n      actual point to render the ghost tile is in the upper region */\n    if (upperBoundAttempts !== 0) {\n      return ret;\n    }\n\n    /* Otherwise, it is in the lower region */\n    while (!this.isMoveValid(tileX, 0, ret, 0, tile, tileRotate, 0)) {\n      ret -= 1;\n    }\n\n    return ret;\n  }\n\n  /**\n   * @brief: prepareGhostTileY: Get the Y coord of the ghost tile\n   * of a newly spawned tile\n   * @note: This is basically a quick hack - Instead of having to\n   * call other functions (findGhostTileY), we can simply just\n   * calculate the ghost tile's Y coordinate as it is only\n   * [the higest pixel - number of pixels to the pivot\n   * (0, 0) of the init tile]\n   * @param[in]: tile - Actual tile type\n   * @param[in]: tileRotate - Actual tile's rotation\n   */\n  prepareGhostTileY(tile: TetrisConsts.Tile,\n    tileRotate: TetrisConsts.Rotation): number {\n    const { boardHeight } = this.props;\n\n    const tiles = TetrisConsts.TILES_COORDS_ARR;\n\n    const pixelsToPivot = tiles[tile][tileRotate][\n      TetrisConsts.UPPER_Y_INDEX][TetrisConsts.Y_INDEX];\n    return boardHeight - 1 - pixelsToPivot;\n  }\n\n  /**\n   * @brief: renderTile: Render the desired tile\n   * @note: Field state will be updated after the function returns\n   * @param[in]: tileX - Desired tile's x\n   * @param[in]: tileY - Desired tile's y\n   * @param[in]: tile - Desired tile type\n   * @param[in]: tileRotate - Desired tile's rotation\n   * @param[in]: renderValue - Render value (color of tile)\n   */\n  renderTile(tileX: number,\n    tileY: number,\n    tile: TetrisConsts.Tile,\n    tileRotate: TetrisConsts.Rotation,\n    renderValue: number): void {\n    const { field } = this.state;\n\n    const tiles = TetrisConsts.TILES_COORDS_ARR;\n\n    const newField = field;\n\n    for (let pixelIter = 0; pixelIter < TetrisConsts.MAX_PIXEL; pixelIter += 1) {\n      const xToRender = tileX + tiles[tile][tileRotate][pixelIter][TetrisConsts.X_INDEX];\n      const yToRender = tileY + tiles[tile][tileRotate][pixelIter][TetrisConsts.Y_INDEX];\n      if (yToRender >= 0) {\n        newField[xToRender].colArr[yToRender] = renderValue;\n      }\n    }\n\n    this.setState(() => ({\n      field: newField,\n    }));\n  }\n\n  render(): JSX.Element {\n    const {\n      boardHeight, boardWidth, firstGameStart,\n    } = this.props;\n    const {\n      score, level, heldTile, field, spawnedTiles,\n    } = this.state;\n\n    const renderField: number[][] = [];\n\n    for (let y = 0; y < boardHeight; y += 1) {\n      const row = [];\n      for (let x = 0; x < boardWidth; x += 1) {\n        row.push(field[x].colArr[y]);\n      }\n      renderField.push(row);\n    }\n\n    return (\n      <div className=\"game-wrap\">\n        <TetrisBoard\n          field={renderField}\n          score={score}\n          level={level}\n          spawnedTiles={spawnedTiles}\n          heldTile={heldTile}\n          firstGameStart={firstGameStart}\n        />\n      </div>\n    );\n  }\n}\n\nexport default Tetris;\n","import React from 'react';\nimport { scaleDown as Menu, State } from 'react-burger-menu';\n\nimport LoginForm from '../../components/Form/LoginForm';\nimport GameControl from '../../components/Prompt/GameControl';\nimport Tetris from '../../components/Game/Tetris';\n\ntype LandingState = {\n  formOpened: boolean;\n  gamePaused: boolean;\n  gameRestart: boolean;\n  gameOver: boolean;\n  firstGameStart: boolean;\n  userAuth: boolean;\n};\n\nclass Landing extends React.Component<Record<string, unknown>, LandingState> {\n  constructor(props: Record<string, unknown>) {\n    super(props);\n\n    this.handleFormState = this.handleFormState.bind(this);\n\n    this.state = {\n      formOpened: false,\n      gamePaused: true,\n      gameRestart: false,\n      gameOver: false,\n      firstGameStart: false,\n      userAuth: false,\n    };\n  }\n\n  /**\n   * @brief: handleFormState: Callback to sync the state being set\n   * using our own onClick event with the state being set using the\n   * default means in the react-burger-menu module\n   * @param[in]: state - The state of the menu\n   */\n  handleFormState(state: State): void {\n    this.setState({ formOpened: state.isOpen });\n  }\n\n  render(): JSX.Element {\n    const {\n      formOpened, gamePaused, gameRestart, gameOver, firstGameStart, userAuth,\n    } = this.state;\n\n    return (\n      <div id=\"outer-container\">\n        <Menu\n          customBurgerIcon={false}\n          isOpen={formOpened}\n          onStateChange={(state: State): void => this.handleFormState(state)}\n          outerContainerId=\"outer-container\"\n          pageWrapId=\"game-container\"\n          width=\"600px\"\n        >\n          <LoginForm />\n        </Menu>\n        <div id=\"game-container\">\n          <GameControl\n            isOver={gameOver}\n            toggleGame={(): void => this.setState({ gamePaused: !gamePaused })}\n            restartGame={(): void => this.setState({\n              gamePaused: false,\n              gameRestart: !gameRestart,\n            })}\n            openForm={(): void => this.setState({ formOpened: true })}\n            toggleFirstGame={(): void => this.setState({\n              gamePaused: !gamePaused,\n              firstGameStart: true,\n            })}\n          />\n          <Tetris\n            boardWidth={14}\n            boardHeight={23}\n            gamePaused={gamePaused}\n            gameRestart={gameRestart}\n            gameState={(isOver: boolean): void => this.setState({ gameOver: isOver })}\n            firstGameStart={firstGameStart}\n            userAuth={userAuth}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Landing;\n","import React from 'react';\n\nimport GameControl from '../../components/Prompt/GameControl';\nimport Tetris from '../../components/Game/Tetris';\n\ntype HomeState = {\n  gamePaused: boolean;\n  gameRestart: boolean;\n  gameOver: boolean;\n  firstGameStart: boolean;\n  userAuth: boolean;\n};\n\nclass Home extends React.Component<Record<string, unknown>, HomeState> {\n  constructor(props: Record<string, unknown>) {\n    super(props);\n\n    this.state = {\n      gamePaused: true,\n      gameRestart: false,\n      gameOver: false,\n      firstGameStart: false,\n      userAuth: true,\n    };\n  }\n\n  render(): JSX.Element {\n    const {\n      gamePaused, gameRestart, gameOver, firstGameStart, userAuth,\n    } = this.state;\n\n    return (\n      <div id=\"outer-container\">\n        <div id=\"game-container\">\n          <GameControl\n            isOver={gameOver}\n            toggleGame={(): void => this.setState({ gamePaused: !gamePaused })}\n            restartGame={(): void => this.setState({\n              gamePaused: false,\n              gameRestart: !gameRestart,\n            })}\n            toggleFirstGame={(): void => this.setState({\n              gamePaused: !gamePaused,\n              firstGameStart: true,\n            })}\n          />\n          <Tetris\n            boardWidth={14}\n            boardHeight={23}\n            gamePaused={gamePaused}\n            gameRestart={gameRestart}\n            gameState={(isOver: boolean): void => this.setState({ gameOver: isOver })}\n            firstGameStart={firstGameStart}\n            userAuth={userAuth}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default Home;\n","import React from 'react';\nimport axios from 'axios';\n\nimport './ProfileCard.css';\n\ntype ProfileCardState = {\n  emailAddress: string;\n  displayName: string;\n  profilePic: string;\n  scores: Array<{\n    score: number;\n    timestamp: string;\n  }>;\n};\n\nclass ProfileCard extends React.Component<Record<string, unknown>, ProfileCardState> {\n  constructor(props: Record<string, unknown>) {\n    super(props);\n\n    this.state = {\n      emailAddress: '',\n      displayName: '',\n      profilePic: '',\n      scores: [],\n    };\n  }\n\n  async componentDidMount(): Promise<void> {\n    const { data: userInfo } = await axios.get('/api/user/');\n    const { data: userScores } = await axios.get('/api/user/scores');\n\n    this.setState({\n      emailAddress: userInfo.emailAddress,\n      displayName: userInfo.displayName,\n      profilePic: userInfo.profilePic,\n      scores: userScores.scores,\n    });\n  }\n\n  renderScores(): JSX.Element {\n    const { scores: userScores } = this.state;\n\n    return userScores.length ? (\n      <div className=\"high-score\">\n        <p className=\"mb-4\">YOUR HIGH SCORES</p>\n        {userScores.map((value) => {\n          const { score, timestamp } = value;\n\n          return (\n            <div className=\"record\">\n              <div className=\"score\">{score}</div>\n              <div className=\"timestamp\">{timestamp}</div>\n            </div>\n          );\n        })}\n      </div>\n    ) : (\n      <div />\n    );\n  }\n\n  render(): JSX.Element {\n    const {\n      emailAddress, displayName, profilePic,\n    } = this.state;\n\n    const profilePicURL = {\n      backgroundImage: `url(${profilePic})`,\n    };\n\n    return (\n      <div className=\"profile-card-wrap\">\n        <div className=\"profile-card\">\n          <div className=\"profile-cl\">\n            <div className=\"user-profile-pic\" style={profilePicURL} />\n          </div>\n          <div className=\"profile-cl\">\n            <div className=\"user-info\">\n              <div className=\"mb-2\">\n                DISPLAY NAME\n                <p>{displayName}</p>\n              </div>\n              <div className=\"mb-2\">\n                EMAIL ADDRESS\n                <p>{emailAddress}</p>\n              </div>\n            </div>\n          </div>\n        </div>\n        {this.renderScores()}\n      </div>\n    );\n  }\n}\n\nexport default ProfileCard;\n","import React from 'react';\n\nimport ProfileCard from '../../components/Form/ProfileCard';\n\nconst Profile: React.FC<Record<string, unknown>> = () => (\n  <div id=\"profile-container\">\n    <ProfileCard />\n  </div>\n);\n\nexport default Profile;\n","import React from 'react';\nimport {\n  BrowserRouter as Router, Route, Switch,\n} from 'react-router-dom';\n\nimport Landing from './pages/Landing/Landing';\nimport Home from './pages/Home/Home';\nimport Profile from './pages/Profile/Profile';\n\nconst App = (): JSX.Element => (\n  <Router>\n    <Switch>\n      <Route exact path=\"/\">\n        <Landing />\n      </Route>\n      <Route exact path=\"/home\">\n        <Home />\n      </Route>\n      <Route exact path=\"/profile\">\n        <Profile />\n      </Route>\n    </Switch>\n  </Router>\n);\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport App from './App';\nimport './index.css';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}